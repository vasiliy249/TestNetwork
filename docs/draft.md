В данном документе описывается разрабатываемый стандарт протокола передачи данных в децентрализованной сети. Протокол предназначен для надёжной передачи больших объёмов данных «особым» участникам сети.

Работа сети по рассматриваемому протоколу осуществляется по принципу распределённой хэш-таблицы (DHT) с использованием пространства, метрика которого основана на операциях над IP адресами (?). Топология пространства обладает таким свойством, что обмен данными между узлами увеличивает полезную информацию, хранящуюся в сети (знание друг друга узлов).

На каждом узле работает UDP и TCP сервер (каждый из которых ответственен за обработку своих команд).

Каждый узел имеет композитный идентифкатор: IP адрес + 160-битный идентификатор. Первая часть используется для маршрутизации и в качестве аргумента метрики (?). Вторая часть используется для идентификации не только узлов, но и передаваемых данных. Это разделение обусловлено тем, что в классических DHT-системах «близость» двух узлов вычисляется из «сходства» их ID, и не имеет никакого отношения к их географической близости.

Также в структуре узла должна быть информация о наличии связи с центральными узлами.

### Основные определения:

initial list – список, содержащий актуальную информацию о существующих участниках сети

bootstrap-узел – специализированный узел сети, поддерживающий initial list в актуальном состоянии и обеспечивающий новых участников сети этой информацией. В непосредственной передаче данных не участвует. Адреса bootstrap-узлов заранее известны и hard-coded.

k-buckets – контейнер с информацией об узлах, построенный с использованием метрики, представляет собой бинарное дерево. Хранится на каждом узле и используется для оптимизации маршрутизации.

### Сообщения

Все сообщения содержат идентификатор сообщения (должны быть строками или, например, определёнными значениями байта?), композитный идентификатор иницииатора, случайное значение (magic coockie), которое ожидается в ответном сообщении.

Сообщения протокола:

- PING – сообщение с целью проверки соединения.
- NEW DATA – сообщение, целью которого является оповещение участников сети о появлении новых данных в сети, требующих «доставки» в специальные узлы. В состав сообщения дополнительно входит размер данных, разбиение данных (?).
- GET INIT – сообщение, в ответ на которое, bootstrap узел отправляет список узлов (?)
- GET NEED (?) – сообщение от агента центральному узлу, с целью получения идентификаторов данных, которые необходимы центральному узлу
- STORE – хранение пары <key, value>

### Примеры

Алгоритм работы сети при добавлении нового участника:
- регистрация нового участника в общем реестре и выдача идентификатора узла (или же он сам генерирует рандомный идентификатор)
- получение initial list от bootstrap-узла(ов)
- генерация своих k-buckets на основе initial list, ping этих узлов.

Алгоритм работы сети при получении новых данных:
- передача в сеть по udp сообщения о новых данных (содержит ID или IP узла, у которого появились данные, ID данных, размер)
- узел, которому необходимо передать данные (как правило, исследовательский центр), переходит в состоние «необходимы такие-то данные» и начинает отвечать на запросы GET NEED от других узлов
- узлы, опросившие центр и получившие список идентификаторов необходимых данных, ищут в своих k-buckets узлы, расстояние до которых минимально от необходимых данных (расстояние между 160b ID данных и 160b ID узла), и передают им эту информацию
- когда сообщения дойдут до узла, у которого есть необходимые данные, он передаст их на сервер (?). В случае отсутствия стабильного соединения данного узла с центральным, он найдёт ближайший (тут действует метрика по IP) узел, у которого есть связь с центральным узлом, передаст ему данные и ответственность за данные перейдёт на новый узел (тут также надо изменить store узла, ответственного за эти данные, т.е. послать сообщение STORE)

Алгоритм обновления информации в k-buckets:
- получение информации в сообщении от какого-либо узла
- в случае отсутствия данного узла в k-bucket - запись его в конец k-bucket'a
- в случае наличия - перемещение в конец k-bucket
- в случае переполнения - последовательный опрос первых в k-bucket (если кто-то не ответил, удаляется из k-bucket, и новый узел помещается в конец)

