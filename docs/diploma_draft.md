# Введение

## Актуальность работы

В связи с прогрессом в области информационных технологий наблюдается рост программного и аппаратного обеспечения, позволяющего решать многие задачи в различных сферах деятельности человека. Люди стали активно использовать платёжные системы, WEB-ресурсы для передачи данных, запоминающее устройства для записи и хранения важной информации и т.п.

Наряду с этим, возникает потребность в передаче больших объёмов данных с высоким уровнем надежности и конфинденциальности, а также в эффективном хранении этих данных. Примером этому могут послужить задачи компьютерной криминалистики (на англ. computer forensics) [1]. В настоящее время растёт пропускная способность физических интерфейсов компьютеров, а также скорость передачи данных по сети. Не смотря на это, получение необходимых цифровых данных для анализа по-прежнему занимает много времени. Также встаёт вопрос об эффективном хранении данных, заключающийся снижении занимаемоего пространства и ускорения процедуры поиска.

Другой пример – это получение результатов тестирования в образовательной сфере (знание языка, государственные экзамены и т.п.) с целью получения статистических данных и проверки ...(?)

На данный момент решение большинства из этих задач основано на применении клиент-серверной архитектуры, в которой постоянная стабильная связь клиента с сервером является узким местом. Если рассматривать задачи компьютерной криминалистики, то главным требованием будет криминалистически правильный [2] сбор информации, обеспечивающий целостность целевых данных.

В связи с этим, в настояще время нет программного обеспечения, решающего эти задачи в рамках выдвинутых требований. Существует множество инструментов, решающих отдельные подзадачи, но, к сожалению, их использование не возможно из-за ряда ограничений, которые являются для нас принципиальными. К ним относятся высокая стоимость, отсутствие открытого исходного кода под либеральными лицензиями и, как следствие, невозможность модификации программных компонентов под определённые задачи, платная техническая поддержка и т.п.

## Цель работы

Целью данной работы является создание распределенного программного комплекса, осуществляющего сбор и эффективное хранение данных. (Надо ли тут добавлять про оценку гарантированного времени сбора и целостность передаваемых данных?).

## Задачи работы

Для достижения поставленной цели были сформулированы следующие задачи:
* исследование существующих систем сбора данных;
* исследование способов хранения данных;
* разработка прикладного протокола передачи данных;
* интеграция систем сбора и хранения данных;
* апробация программного комплекса.

# Глава 1. Обзор распределенных систем поиска, сбора и хранения данных

## 1.1. Классификации сетей

Существуют два основных типа сетей [3]:

* клиент-серверный,
* одноранговый.

Использование одноранговой архитектуры более приоритетно ввиду большего уровня масштабируемости, автономности, анонимности и отказоустойчивости.

В некоторых случаях, рассматривают третий тип – гибридный, при котором в сеть добавляется координационный узел(лы) [4].

Одноранговая архитектура не подразумевает полное равенство узлов, в таких сетях могут находится супер-узлы, позволяющие управлять маршрутизацией и индексацией данных в сети. В связи с этим, принято классифицировать одноранговые сети по степени централизации [5]:

* централизованные (centralized P2P),
* полностью децентрализованные (pure P2P),
* гибридные (hybrid P2P).

Существует несколько способов организации связей между узлами в оверлейной сети, а также различные способы размещения и индексирования ресурсов. Поэтому, для сетей однорангового типа можно ввести ещё одну классификацию [5]:

* структурированные,
* неструктурированные,
* гибридные.

В неструктурированных одноранговых системах нет определенной накладываемой на оверлейную сеть структуры, она формируется узлами, которые случайным образом соединяются друг с другом [6]. Поскольку все узлы в сети одинаковые и содержат относительно немного маршрутизационной информации, неструктурированная сеть устойчива к одновременному присоедниению или оттоку большого количества узлов [7].

Из недостатков неструктурированной сети можно отметить неэффективный поиск информации и большую нагрузку на сеть.

В структурированных одноранговых сетях оверлейная сеть имеет определённую топологию, которая гарантирует, что любой узел может эффективно (как правило, за O(logN) операций) осуществлять процедуру поиска даже очень редкого ресурса. Большинство структурированных одноранговых сетей организованы по принципу распределённой хэш таблицы (DHT). Для того, чтобы трафик в сети орагнизовывался эффективным образом, каждый узел должен поддерживать в актуальном состоянии список ближайших (по какой-либо метрике) улов – это делает структурированную сеть менее устойчивой к высокому притоку/оттоку участников.

Примеры классификации сетей:

1.  HTTP, FTP – клиент-серверная;
2.	Gnutella 0.4 – одноранговая, полностью децентрализованная, неструктурированная;
3.	Napster – одноранговая, централизованная, неструктурированная;
4.	Gnutella 0.6 – одноранговая, гибридная, неструктурированная;
5.	Chord, Kademlia, Pastry – одноранговая, полностью децентрализованная, структурированная.

Ввиду того, что в рамках рассматриваемой задачи маловероятен высокий приток/отток узлов за короткий промежуток времени, а также важна скорость выполнения запросов, низкий сетевой трафик, возможность масштабирования – было принято решение выбрать одноранговую, полностью децентрализованную, структурированную архитектуру сети.

## 1.2. Обзор класса распределенных систем типа «распределенная хэш таблица»

Большинство одноранговых структурированных систем представляет собой распределенную хэш таблицу (distributed hash table – DHT) [8].

Рассмотрим главных представителей данного класса.

* Chord [9]
* Pastry [10]
* Kademlia [11]

## 1.3. Обзор систем хранения данных

...

# Глава 2. Разработка распределенной системы сбора данных

## 2.1. Прикладной протокол передачи данных

Протокол предназначен для надёжной передачи больших объёмов данных «особым» участникам сети.

Работа сети по рассматриваемому протоколу осуществляется по принципу распределённой хэш-таблицы (DHT) с использованием пространства, метрика которого основана на операциях над IP адресами (?). Топология пространства обладает таким свойством, что обмен данными между узлами увеличивает полезную информацию, хранящуюся в сети (знание друг друга узлов).

На каждом узле работает UDP и TCP сервер (каждый из которых ответственен за обработку своих команд).

Каждый узел имеет композитный идентифкатор: IP адрес + 160-битный идентификатор. Первая часть используется для маршрутизации и в качестве аргумента метрики (?). Вторая часть используется для идентификации не только узлов, но и передаваемых данных. Это разделение обусловлено тем, что в классических DHT-системах «близость» двух узлов вычисляется из «сходства» их ID, и не имеет никакого отношения к их географической близости.

Также в структуре узла должна быть информация о наличии связи с центральными узлами.

### Основные определения:

initial list – список, содержащий актуальную информацию о существующих участниках сети

bootstrap-узел – специализированный узел сети, поддерживающий initial list в актуальном состоянии и обеспечивающий новых участников сети этой информацией. В непосредственной передаче данных не участвует. Адреса bootstrap-узлов заранее известны и hard-coded.

k-buckets – контейнер с информацией об узлах, построенный с использованием метрики, представляет собой бинарное дерево. Хранится на каждом узле и используется для оптимизации маршрутизации.

### Сообщения

Все сообщения содержат идентификатор сообщения (должны быть строками или, например, определёнными значениями байта?), композитный идентификатор иницииатора, случайное значение (magic coockie), которое ожидается в ответном сообщении.

Сообщения протокола:

- PING – сообщение с целью проверки соединения.
- NEW DATA – сообщение, целью которого является оповещение участников сети о появлении новых данных в сети, требующих «доставки» в специальные узлы. В состав сообщения дополнительно входит размер данных, разбиение данных (?).
- GET INIT – сообщение, в ответ на которое, bootstrap узел отправляет список узлов (?)
- GET NEED (?) – сообщение от агента центральному узлу, с целью получения идентификаторов данных, которые необходимы центральному узлу
- STORE – хранение пары <key, value>

### Примеры

Алгоритм работы сети при добавлении нового участника:
- регистрация нового участника в общем реестре и выдача идентификатора узла (или же он сам генерирует рандомный идентификатор)
- получение initial list от bootstrap-узла(ов)
- генерация своих k-buckets на основе initial list, ping этих узлов.

Алгоритм работы сети при получении новых данных:
- передача в сеть по udp сообщения о новых данных (содержит ID или IP узла, у которого появились данные, ID данных, размер)
- узел, которому необходимо передать данные (как правило, исследовательский центр), переходит в состоние «необходимы такие-то данные» и начинает отвечать на запросы GET NEED от других узлов
- узлы, опросившие центр и получившие список идентификаторов необходимых данных, ищут в своих k-buckets узлы, расстояние до которых минимально от необходимых данных (расстояние между 160b ID данных и 160b ID узла), и передают им эту информацию
- когда сообщения дойдут до узла, у которого есть необходимые данные, он передаст их на сервер (?). В случае отсутствия стабильного соединения данного узла с центральным, он найдёт ближайший (тут действует метрика по IP) узел, у которого есть связь с центральным узлом, передаст ему данные и ответственность за данные перейдёт на новый узел (тут также надо изменить store узла, ответственного за эти данные, т.е. послать сообщение STORE)

Алгоритм обновления информации в k-buckets:
- получение информации в сообщении от какого-либо узла
- в случае отсутствия данного узла в k-bucket - запись его в конец k-bucket'a
- в случае наличия - перемещение в конец k-bucket
- в случае переполнения - последовательный опрос первых в k-bucket (если кто-то не ответил, удаляется из k-bucket, и новый узел помещается в конец)


## Список литературы
1.	Федотов Н.Н. Форензика – компьютерная криминалистика. Москва: «Юридический мир», 2007. 360 с.
2.	Иванищев В.О., Интроспекционный анализ динамики оперативной памяти операционных систем семейства Windows NT, 2015
3.	Peer-to-peer, https://en.wikipedia.org/wiki/Peer-to-peer
4.	Vasilios Darlagiannis, Hybrid Peer-to-Peer Systems, 2005
5.	Dr. Claudia Müller-Birn, Peer-to-peer systems, 2012
6.	A Survey of Structured P2P Systems for RDF Data Storage and Retrieval". Filali, Imen, 2011, p. 21
7.	Xing Jin, S.-H. Gary Chan, Unstructured Peer-to-Peer Network Architectures, 2010
8.	Rajiv Ranjan, Aaron Harwood, Rajkumar Buyya, Peer-to-Peer Based Resource Discovery in Global Grids: A Tutorial, 2007
9.	Ion Stoica, Robert Morris, David Karger, M. Frans Kaashoek, Hari Balakrishnan, Chord: A Scalable Peer-to-peer Lookup Service for Internet Applications, 2001
10.	Antony Rowstron, Peter Druschel, Pastry: Scalable, decentralized object location and routing for large-scale peer-to-peer systems, 2001
11.	Petar Maymounkov, David Mazieres, Kademlia: A peer-to-peer Information System Based on the XOR Metric, 2002

